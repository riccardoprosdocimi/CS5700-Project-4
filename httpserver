#!/usr/bin/env python3
import argparse
import http
import json
import socket
import subprocess
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer
from socketserver import ThreadingMixIn

import utils
from cache import RepliCache
from utils import get_local_ip

PORT = 25016
ORIGIN_PORT = "8080"
ORIGIN_SERVER = "cs5700cdnorigin.ccs.neu.edu"
GRADING_BEACON_PATH = "/grading/beacon"
DEBUG_CACHE = "/debug/cache"
DEBUG_LOGS = "/debug/logs"

cache_test_mode = False
if cache_test_mode:
    print("Cache running in test mode")

repli_cache = RepliCache(test_mode=cache_test_mode)


class CdnHttpHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == GRADING_BEACON_PATH:
            self.send_response(204)
            self.send_header("Host", socket.gethostname())
            self.end_headers()
        elif self.path == DEBUG_CACHE:
            resp = json.dumps(repli_cache.articles, default=lambda obj: obj.__dict__)

            self.send_response(200)
            self.send_header("Content-Type", "application/json; charset=utf-8")
            self.send_header("Content-Length", str(len(resp)))
            self.send_header("Host", socket.gethostname())
            self.end_headers()
            self.wfile.write(resp.encode())
        elif self.path == DEBUG_LOGS:
            with open("logs.txt") as fd:
                logs = fd.read()

            self.send_response(200)
            self.send_header("Content-Type", "text/plain; charset=utf-8")
            self.send_header("Content-Length", str(len(logs)))
            self.send_header("Host", socket.gethostname())
            self.end_headers()
            self.wfile.write(logs.encode())
        else:
            found, data = repli_cache.get(self.path)
            if not found:
                self.send_error(code=http.HTTPStatus.NOT_FOUND)
                return

            self.send_response(200)
            self.send_header("Content-Type", "text/html; charset=utf-8")
            self.send_header("Content-Encoding", "gzip")
            self.send_header("Content-Length", str(len(data)))
            self.send_header("Host", socket.gethostname())
            self.end_headers()
            self.wfile.write(data)

    def do_POST(self):
        if self.path == "/measure":
            content_length = int(self.headers["Content-Length"])
            post_data = self.rfile.read(content_length).decode()
            ips_to_measure = json.loads(post_data)

            measurements = {}
            measure_thread = threading.Thread(target=measure, args=(ips_to_measure, measurements))
            measure_thread.start()
            avg_cpu_usage = utils.get_avg_cpu_percent()
            measure_thread.join()

            response = json.dumps({"rtts": measurements, "cpu": avg_cpu_usage})
            self.send_response(200)
            self.send_header("Content-Type", "application/json; charset=utf-8")
            self.send_header("Content-Length", str(len(response)))
            self.send_header("Host", socket.gethostname())
            self.end_headers()
            self.wfile.write(response.encode())
        else:
            self.send_error(code=http.HTTPStatus.NOT_FOUND)


class ThreadingSimpleServer(ThreadingMixIn, HTTPServer):
    pass


def measure(client_ips: list, measurements: dict):
    from sys import maxsize

    scamper_output = subprocess.check_output(
        ["scamper", "-p", "10", "-c", "ping", "-i", *client_ips, "-O", "json"]
    ).decode()
    scamper_output = scamper_output.split("\n")[1:-2]
    for line in scamper_output:
        json_object = json.loads(line)
        dst_ip = json_object["dst"]
        if "avg" in json_object["statistics"]:
            rtt = json_object["statistics"]["avg"]
            measurements[dst_ip] = rtt
        else:
            measurements[dst_ip] = maxsize


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-p", type=int, help="the port number the server will bind to")
    parser.add_argument("-o", type=str, help="the name of the origin server")
    args = parser.parse_args()
    return args


def main():
    global ORIGIN_SERVER
    args = parse_args()
    port = args.p
    ORIGIN_SERVER = args.o
    web_server = ThreadingSimpleServer((get_local_ip(), port), CdnHttpHandler)
    try:
        print(f"Starting replica at http://{get_local_ip()}:{port}")
        web_server.serve_forever()
    except KeyboardInterrupt:
        web_server.server_close()
        print("Server stopped")


if __name__ == "__main__":
    main()
