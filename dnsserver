#!/usr/bin/env python3
import argparse
import threading
from geo import find_best_replica
from dnslib.dns import RR
from dnslib.server import DNSServer, DNSLogger, DNSError
from utils import get_local_ip
from dataclasses import dataclass
import time
from urllib import request
import json
from replicas import REPLICAS


DNS_SERVER = "localhost"  # "proj4-dns.5700.network"
DNS_SERVER_IP = "97.107.140.73"

CDN_NAME = "cs5700cdn.example.com"
TTL = 45


class Resolver:
    CLIENT_IPS: set = set()
    CLIENT_REPLICA_MAP: dict = dict()

    @staticmethod
    def resolve(request, handler):
        if request.q.qname == CDN_NAME:
            client = handler.client_address[0]
            Resolver.CLIENT_IPS.add(client)
            response = request.reply()
            if client in Resolver.CLIENT_REPLICA_MAP.keys():
                replica = Resolver.CLIENT_REPLICA_MAP[client]
            else:
                replica = find_best_replica(client)
            replica_domain_name, replica_ip = REPLICAS[replica]
            response.add_answer(
                *RR.fromZone(f"{replica_domain_name}. {TTL} A {replica_ip}"))
            return response

        raise DNSError(f"Not authoritative for {request.q.qname}")


@dataclass()
class DNSProxy:
    server: DNSServer
    resolver: Resolver
    port: int

    def run(self):
        try:
            self.server.start_thread()
            print('DNS server running.')
            measurements_thread = threading.Thread(
                target=self._get_all_measurements)
            measurements_thread.start()
            measurements_thread.join()
        except KeyboardInterrupt:
            self.stop()

    def stop(self):
        self.server.stop()
        print('\nDNS server stopped.')

    def _get_all_measurements(self) -> None:
        '''
        - Keep a queue/list of measurements.
        - Spin a thread to request measurements for each thread from each replicate endpoint.
        - As long as the measurement queue has data, set the best client to replica map.
        '''
        while True:
            # if len(self.resolver.CLIENT_IPS) == 0:
            #     time.sleep(3)
            #     continue
            measurement_queue = list()
            measurement_thread_queue = list()
            lock = threading.Lock()
            for replica in REPLICAS:
                measurement_thread = threading.Thread(
                    target=self._request_measurement, args=(replica, measurement_queue, lock))
                measurement_thread_queue.append(measurement_thread)
                measurement_thread.start()
            # join threads
            for thread in measurement_thread_queue:
                thread.join()

            # calculate best client to replica
            if len(measurement_queue) > 0:
                self._set_best_replicas(measurement_queue)
            time.sleep(30)

    def _request_measurement(self, replica: tuple, measurement_queue: list, lock: threading.Lock) -> json:
        '''
        Make a get request for a replica to get measurements, and add the measurement for this replica
        to the list of all measurements.
        Param replica: a replica tuple containing the name and ip of the replica.
        measurement_queue: a list of all replica measurements. The measurements for this replica will be added to list.
        '''
        # format request to send
        req = request.Request(
            'http://' + replica[0] + ':' + str(self.port) + '/measure')
        req.add_header('Content-Type', 'application/json; charset=utf-8')
        client_list = list(self.resolver.CLIENT_IPS)
        body = json.dumps(client_list)
        body_bytes = body.encode('utf-8')
        # make request and process data
        res = request.urlopen(req, body_bytes)
        # read response data
        data = res.read()
        json_data = json.loads(data.decode('utf-8'))
        # json_data = {"rtts": {
        #     "0.0.0.0": str(randrange(0, 50)),
        #     "1.1.1.1": str(randrange(0, 50)),
        #     "2.2.2.2": str(randrange(0, 50)),
        # }, "cpu": str(randrange(0, 100))}
        json_data["replica"] = replica
        # add json response to measurement queue
        with lock:
            measurement_queue.append(json_data)

    def _set_best_replicas(self, replica_measurements: list) -> None:
        '''
        Sets the client to replica map in state.
        Logic:
        - Iterate over each replica measurement.
        - For each replica measurement, get a client ip.
        - Store the client ip as a key in the client replica map.
        - Get the rtt for that replica client.
        _ If the rtt is less than the previous replica rtt,
            set that replica as the value in the client replica map.
        '''

        client_replica_map = {}
        for replica in replica_measurements:
            for client_key in replica['rtts']:
                best_replica = {
                    'replica': replica['replica'],
                    'rtt': int(replica['rtts'][client_key])
                }
                # Upsert client ip as key in client_replica_map
                client_replica = client_replica_map.setdefault(
                    client_key, best_replica)
                if int(replica['rtts'][client_key]) < int(client_replica['rtt']):
                    client_replica_map[client_key] = best_replica
            Resolver.CLIENT_REPLICA_MAP = client_replica_map

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-p", type=int, help="the port number the server will bind to")
    parser.add_argument(
        "-n", type=str, help="the CDN-specific name that the server translates to an IP.")
    args = parser.parse_args()
    return args


def main():
    global CDN_NAME
    args = parse_args()
    port = args.p
    CDN_NAME = args.n
    resolver = Resolver()
    logger = DNSLogger(prefix=False)
    server = DNSServer(resolver, logger=logger,
                       port=port, address=get_local_ip())
    proxy = DNSProxy(server, resolver, port)
    proxy.run()


if __name__ == "__main__":
    main()
